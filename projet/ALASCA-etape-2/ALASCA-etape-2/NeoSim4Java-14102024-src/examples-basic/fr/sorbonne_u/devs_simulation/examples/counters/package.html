<!-- fr.sorbonne_u.devs_simulation.architectures ---------------------------- -->
<html>
<body>
<p><b>DEVS simulation example: simple counter models.</b></p>

<table border="2" width="100%">
<tr><th align="left" colspan="1">Licence</th></tr>
<tr>
<td width="100%">
<p>Copyright Jacques Malenfant, Sorbonne Universite.</p>
<p>Jacques.Malenfant@lip6.fr</p>

<p>
This software is a computer program whose purpose is to provide a new
implementation of the DEVS simulation <i>de facto</i> standard for Java.
</p>
<p>
This software is governed by the
<a href="../../../../images/Licence_CeCILL-C_V1-en.html">CeCILL-C</a>
license under French law and
abiding by the rules of distribution of free software.  You can use,
modify and/ or redistribute the software under the terms of the
CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
URL <a href="http://www.cecill.info">http://www.cecill.info</a>.
</p>
<p>
As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability. 
</p>
<p>
In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or 
data to be ensured and,  more generally, to use and operate it in the 
same conditions as regards security. 
</p>
<p>
The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms.
</p>
</td>
</tr>
</table>

<p>
This package provides a first simple DEVS simulation example that merely uses
one atomic model, but shows how to use it in a simulation architecture, including
a simple model factory.
</p>
<p>
The organisation of the models are as follows:
</p>
<ul>
<li><code>BasicCounterModel</code> is the central model in this example. It is a
  deterministic atomic model that executes internal transitions at a regular rate, its
  step duration, and each of these transitions simply increments a counter by 1.
  This model shows how to use the simulation run parameters to set some
  internal parameter to different value at each simulation run. Here, the start
  value of the counter and the simulation step duration can be set through run
  parameters. In the simulations, a first example of runs uses one
  <code>BasicCounterModel</code> instance and a second uses two.</li>
<li><code>BasicCounterCoupledModel</code> is a very simple coupled model
  example that is required to set up the second run example with two atomic
  model instances. When a simulation architecture contains more that a unique
   atomic model, at least one coupled model is required to construct a correct
   simulation architecture coordinating the different atomic model instances.</li>
<li><code>BasicCounterModelFactory</code> defines a factory used to create
  <code>BasicCounterModel</code> instances. Factories are useful when model
  instances require more construction parameters that the ones fixed by the
  framework and its <code>AtomicModel</code> (or <code>CoupledModel</code>)
  abstract class. Due to the algorithmic creation of model instances through
  simulation architecture descriptions, the instantiation of model classes is
  automatic, hence requiring factories in this case.</li>
</ul>
<p>
To show the different way to run simulations, the package contains several
"main" classes. <code>SimulationMain</code> shows how to instantiate a
simulation model using a unique atomic model and run it in a logical simulation
time while <code>RTSimulationMain</code> shows how to run the same model
but in real time. <code>SimulationMain2</code> shows how to create a composite
simulation model from two instance of counter models composed with a coupled
model. The composite model is obtained by first describing the simulation architecture
and then instantiating it. <code>SimulationMain2</code> runs this second example
in logical simulation time while <code>RTSimulationMain2</code> runs it in real time.
</p>

</body>
</html>
