package fr.sorbonne_u.devs_simulation.es.models;

// Copyright Jacques Malenfant, Sorbonne Universite.
// Jacques.Malenfant@lip6.fr
//
// This software is a computer program whose purpose is to provide a new
// implementation of the DEVS simulation <i>de facto</i> standard for Java.
//
// This software is governed by the CeCILL-C license under French law and
// abiding by the rules of distribution of free software.  You can use,
// modify and/ or redistribute the software under the terms of the
// CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
// URL "http://www.cecill.info".
//
// As a counterpart to the access to the source code and  rights to copy,
// modify and redistribute granted by the license, users are provided only
// with a limited warranty  and the software's author,  the holder of the
// economic rights,  and the successive licensors  have only  limited
// liability. 
//
// In this respect, the user's attention is drawn to the risks associated
// with loading,  using,  modifying and/or developing or reproducing the
// software by the user in light of its specific status of free software,
// that may mean  that it is complicated to manipulate,  and  that  also
// therefore means  that it is reserved for developers  and  experienced
// professionals having in-depth computer knowledge. Users are therefore
// encouraged to load and test the software's suitability as regards their
// requirements in conditions enabling the security of their systems and/or 
// data to be ensured and,  more generally, to use and operate it in the 
// same conditions as regards security. 
//
// The fact that you are presently reading this means that you have had
// knowledge of the CeCILL-C license and that you accept its terms.

import java.util.Vector;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.Set;
import fr.sorbonne_u.devs_simulation.es.events.ES_Event;
import fr.sorbonne_u.devs_simulation.es.events.ES_EventI;
import fr.sorbonne_u.devs_simulation.es.events.EventComparator;
import fr.sorbonne_u.devs_simulation.models.AtomicModel;
import fr.sorbonne_u.devs_simulation.models.events.EventI;
import fr.sorbonne_u.devs_simulation.models.time.Duration;
import fr.sorbonne_u.devs_simulation.models.time.Time;
import fr.sorbonne_u.devs_simulation.simulators.interfaces.AtomicSimulatorI;
import fr.sorbonne_u.devs_simulation.utils.InvariantChecking;

// -----------------------------------------------------------------------------
/**
 * The class <code>AtomicES_Model</code> implements the behaviours of atomic
 * model in event scheduling simulation models.
 *
 * <p><strong>Description</strong></p>
 * 
 * <p>
 * ES stands for Event Scheduling (ES) world view, a type of discrete event
 * simulation where the progress of the simulation revolves around
 * event processing, which causes modifications to the state and the
 * scheduling of new events.
 * </p>
 * <p>
 * When casting ES simulations into a DEVS simulation framework, an event list
 * is added to the state to record the events that are scheduled to be simulated
 * in the future (in simulation time). The time advance function hence simply
 * returns the time to go until the next event in the event list.  Internal
 * transitions removes the next event from the event list, computes the next
 * state given this event, produces the future events and schedule them into
 * the event list of the new state. External transitions execute events
 * received from other models on the atomic model.
 * </p>
 * <p>
 * Hence, most of the processing done in state implementation:
 * </p>
 * <ul>
 * <li>the event list contains the list of events to be processed ordered
 *   by the simulation time of their occurrence and their priority if their
 *   time of occurrence is the same;</li>
 * <li>the time advance function returns the delay until the next event
 *   occurrence in simulation time;</li>
 * <li>the output function retrieves from the event list the exported events
 *   to be processed and returns them so that they will be propagated to
 *   their destination models;</li>
 * <li>the internal transition function calls its
 *   <code>processNextEvents</code> method which first retrieves the set of
 *   events that must be executed at the current time from the
 *   event list then for each event in turn it calls the method
 *   <code>executeOn</code> on the event to perform the state modifications
 *   and then its <code>generateAndScheduleNewEvents</code> to add the new
 *   events generated by the current one to the event list of the model;</li>
 * <li>the external transition function is assumed to be called at the
 *   time of occurrence of the external event that is processed immediately
 *   by calling its <code>executeOn</code> method to perform the state
 *   modifications and then its <code>generateAndScheduleNewEvents</code>
 *   method to get the new events generated by the received one and
 *   schedule them into the event list.</li>
 * </ul>
 * <p>
 * The implementation provided here follows the spirit of the description
 * appearing in:
 * </p>
 * <ul>
 * <li>H. Vangheluwe, Discrete Event Modelling and Simulation,
 *   courseware, 2001.</li>
 * </ul>
 * 
 * <p><strong>Glass-box Invariants</strong></p>
 * 
 * <pre>
 * invariant	{@code EVENT_QUEUE_INITIAL_CAPACITY > 0}
 * invariant	{@code eventList != null}
 * </pre>
 * 
 * <p><strong>Black-box Invariants</strong></p>
 * 
 * <pre>
 * invariant	{@code true}	// no more invariant
 * </pre>
 * 
 * <p>Created on : 2018-07-11</p>
 * 
 * @author	<a href="mailto:Jacques.Malenfant@lip6.fr">Jacques Malenfant</a>
 */
public abstract class	AtomicES_Model
extends		AtomicModel
{
	// -------------------------------------------------------------------------
	// Constants and variables
	// -------------------------------------------------------------------------

	private static final long 		serialVersionUID = 1L;
	/** initial number of events that can be stored in the event queue;
	 *  grows as needed after.												*/
	protected static int			EVENT_QUEUE_INITIAL_CAPACITY = 11;
	/** queue of events to be executed by the model; events are scheduled
	 *  to be executed at some time of occurrence in simulated time, hence
	 *  the queue is sorted in ascending order of times of occurrence.		*/
	protected final PriorityQueue<ES_EventI>	eventList;

	// -------------------------------------------------------------------------
	// Invariants
	// -------------------------------------------------------------------------

	/**
	 * return true if the glass-box invariants are observed, false otherwise.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code instance != null}
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param instance	instance to be tested.
	 * @return			true if the white box invariant is observed, false otherwise.
	 */
	protected static boolean	glassBoxInvariants(AtomicES_Model instance)
	{
		assert	instance != null :
				new AssertionError("Precondition violation: instance != null");

		boolean ret = true;
		ret &= InvariantChecking.checkGlassBoxInvariant(
					EVENT_QUEUE_INITIAL_CAPACITY > 0,
					AtomicES_Model.class,
					instance,
					"EVENT_QUEUE_INITIAL_CAPACITY > 0");
		ret &= InvariantChecking.checkGlassBoxInvariant(
					instance.eventList != null,
					AtomicES_Model.class,
					instance,
					"eventList != null");
		return ret;
	}

	/**
	 * return true if the black-box invariants are observed, false otherwise.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code instance != null}
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param instance	instance to be tested.
	 * @return			true if the black-box invariants are observed, false otherwise.
	 */
	protected static boolean	blackBoxInvariants(AtomicES_Model instance)
	{
		assert	instance != null :
				new AssertionError("Precondition violation: instance != null");

		boolean ret = true;
		return ret;
	}

	// -------------------------------------------------------------------------
	// Constructors
	// -------------------------------------------------------------------------

	/**
	 * create an atomic event scheduling model with the given URI (if null,
	 * one will be generated) and to be run by the given simulator (or by the
	 * one of an ancestor coupled model if null) using the given time unit for
	 * its clock.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code uri == null || !uri.isEmpty()}
	 * pre	{@code simulatedTimeUnit != null}
	 * pre	{@code simulationEngine == null || !simulationEngine.isModelSet()}
	 * pre	{@code simulationEngine == null || simulationEngine instanceof AtomicEngine}
	 * post	{@code !isDebugModeOn()}
	 * post	{@code getURI() != null && !getURI().isEmpty()}
	 * post	{@code uri == null || getURI().equals(uri)}
	 * post	{@code getSimulatedTimeUnit().equals(simulatedTimeUnit)}
	 * post	{@code getSimulationEngine().equals(simulationEngine)}
	 * </pre>
	 *
	 * @param uri					unique identifier of the model.
	 * @param simulatedTimeUnit		time unit used for the simulation clock.
	 * @param simulationEngine		simulation engine enacting the model.
	 * @throws Exception   			<i>to do</i>.
	 */
	public				AtomicES_Model(
		String uri,
		TimeUnit simulatedTimeUnit,
		AtomicSimulatorI simulationEngine
		) throws Exception
	{
		super(uri, simulatedTimeUnit, simulationEngine);

		this.eventList = new PriorityQueue<ES_EventI>(
								AtomicES_Model.EVENT_QUEUE_INITIAL_CAPACITY,
								new EventComparator<ES_EventI>());

		assert	glassBoxInvariants(this) :
				new AssertionError("Glass-box invariants violation!");
		assert	glassBoxInvariants(this) :
				new AssertionError("Black-box invariants violation!");
	}

	// -------------------------------------------------------------------------
	// Simulation protocol and related methods
	// -------------------------------------------------------------------------

	/**
	 * return true if {@code p} is true for all currently stored events.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code true}	// no precondition.
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param p	predicate to be applied.
	 * @return	true if {@code p} is true for all currently stored events.
	 */
	public boolean		assertOnCurrentStoredEvents(Predicate<? super EventI> p)
	{
		assert	p != null :
				new AssertionError("Precondition violation: p != null");

		return this.currentStoredEvents.stream().allMatch(p);
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#initialiseState(fr.sorbonne_u.devs_simulation.models.time.Time)
	 */
	@Override
	public void			initialiseState(Time initialTime)
	{
		super.initialiseState(initialTime);
		this.eventList.clear();
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.interfaces.ModelI#timeAdvance()
	 */
	@Override
	public Duration		timeAdvance()
	{
		ES_Event next = (ES_Event) this.eventList.peek();
		Duration ret = null;
		while (next != null && next.isCancelled()) {
			this.eventList.remove();
			next = (ES_Event) this.eventList.peek();
		}
		if (next != null) {	
			ret = next.getTimeOfOccurrence().
										subtract(this.getCurrentStateTime());
		} else {
			ret = Duration.INFINITY;
		}
		return ret;
	}

	/**
	 * for event scheduling models, extract all exported events that are in
	 * the event list with a time of occurrence equal to the time of the next
	 * event and return them as the current output.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code true}	// no more preconditions.
	 * post	{@code true}	// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.interfaces.AtomicModelI#output()
	 */
	@Override
	public ArrayList<EventI>	output()
	{
		ArrayList<EventI> ret = null;
		if (!this.eventList.isEmpty()) {
			ret = new ArrayList<EventI>();
			try {
				Iterator<ES_EventI> iter = this.eventList.iterator();
				ES_EventI next = iter.next();
				Time t = next.getTimeOfOccurrence();
				assert	t.equals(this.getTimeOfNextEvent());
				while (next != null && next.getTimeOfOccurrence().equals(t)) {
					if (this.isExportedEventType(next.getClass())) {
						ret.add(next);
					}
					if (iter.hasNext()) {
						next = iter.next();
					} else {
						next = null;
					}
				};
				for (EventI e : ret) {
					this.eventList.remove(e);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
		return ret;
	}

	/**
	 * for event scheduling models, first call
	 * {@code userDefinedInternalTransition} to execute the user-defined model
	 * behaviour (which can manually extract some of the current ES events from
	 * the event list) and then extract the remaining ES events which time of
	 * occurrence is equal to the current state time and execute them in their
	 * order of appearance in the event list.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code true}	// no more preconditions.
	 * post	{@code true}	// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#internalTransition()
	 */
	@Override
	public void			internalTransition()
	{
		if (this.getSimulationEngine().hasDebugLevel(2)) {
			this.logMessage(
					"AtomicES_Model#internalTransition " + this.uri
					+ " time = " + this.getCurrentStateTime()
					+ " next event time = " + this.getTimeOfNextEvent());
		}

		assert	this.getNextTimeAdvance().equals(
					this.getTimeOfNextEvent().subtract(
											this.getCurrentStateTime())) :
				new AssertionError("Precondition violation: "
									+ "getNextTimeAdvance().equals("
									+ "getTimeOfNextEvent().subtract("
									+ "getCurrentStateTime()))");

		Duration elapsedTime =
			this.getTimeOfNextEvent().subtract(this.getCurrentStateTime());
		this.currentStateTime = this.getTimeOfNextEvent();

		// Execute the non ES events and possibly ES events if the model
		// wishes to do so manually.
		this.userDefinedInternalTransition(elapsedTime);

		// Extract the remaining ES events which time of occurrence is equal
		// to the current state time.
		ES_EventI next = null;
		Iterator<ES_EventI> iter = this.eventList.iterator();
		if (iter.hasNext()) {
			next = iter.next();
		}
		Vector<ES_Event> currentEvents = new Vector<ES_Event>();
		while (next != null && next.getTimeOfOccurrence().
									equals(this.getCurrentStateTime())) {
			currentEvents.add((ES_Event)next);
			if (iter.hasNext()) {
				next = iter.next();
			} else {
				next = null;
			}
		}
		for (EventI e : currentEvents) {
			this.eventList.remove(e);
		}
		// Execute the extracted events on the model in their order of
		// priority and schedule the ES events generated by them.
		for (int i = 0 ; i < currentEvents.size() ; i++) {
			ES_Event e = currentEvents.get(i);
			if (!e.isCancelled()) {
				e.executeOn(this);
				this.scheduleEvents(currentEvents.get(i).
												generateNewEvents(this));
			}
		}
		currentEvents.clear();

		// Prepare to proceed to the next internal event(s)
		this.nextTimeAdvance = this.timeAdvance();
		this.timeOfNextEvent = this.currentStateTime.add(this.nextTimeAdvance);	

		if (!this.getTimeOfNextEvent().equals(Time.INFINITY)) {
			assert	this.getTimeOfNextEvent().subtract(
												this.getCurrentStateTime()).
									equals(this.getNextTimeAdvance()) :
					new AssertionError("Postcondition violation: "
									+ "getTimeOfNextEvent().subtract("
									+ "getCurrentStateTime())."
									+ "equals(getNextTimeAdvance())");
		}
	}

	/**
	 * for event scheduling models, first extract all imported events from
	 * the currently stored received events and add them to the event list
	 * so that they will be sorted by their order of execution, then the
	 * user defined external transition method is called to process the
	 * remaining events and possibly the imported events if the model wishes
	 * to do so manually. Imported events not manually processed by the
	 * user defined external transition method will remain in the event list
	 * and they will be executed as internal events by the event scheduling
	 * mechanism.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code true}	// no more preconditions.
	 * post	{@code true}	// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#externalTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			externalTransition(Duration elapsedTime)
	{
		if (this.getSimulationEngine().hasDebugLevel(2)) {
			this.logMessage("AtomicES_Model#externalTransition " + this.uri);
		}

		boolean isRealTime;
		try {
			isRealTime = this.simulationEngine.isRealTime();
		} catch (Exception e) {
			throw new RuntimeException(e) ;
		}
		if (isRealTime) {
			// in the current implementation, when in a real time simulation,
			// the tolerance on the order of events must take into account the
			// precision of the underlying scheduling clock.
			if (!elapsedTime.lessThanOrEqual(getNextTimeAdvance())) {
				StringBuffer sb = new StringBuffer("Warning: ");
				sb.append(this.uri);
				sb.append("#externalTransition elspsed time ");
				sb.append(elapsedTime.getSimulatedDuration());
				sb.append(" is larger than the next time advance ");
				sb.append(getNextTimeAdvance().getSimulatedDuration());
				sb.append("!");
				System.err.println(sb.toString());
			}
		} else {
			assert	this.getNextTimeAdvance().greaterThanOrEqual(elapsedTime) :
					new AssertionError("Precondition violation: "
									+ "getNextTimeAdvance()."
									+ "greaterThanOrEqual(elapsedTime)");
		}
		assert	this.getCurrentStateTime().add(elapsedTime).
								lessThanOrEqual(this.getTimeOfNextEvent()) :
				new AssertionError("Precondition violation: "
									+ "getCurrentStateTime().add(elapsedTime)."
									+ "lessThanOrEqual(getTimeOfNextEvent())");

		this.currentStateTime = this.currentStateTime.add(elapsedTime);

		// Extract imported ES events from the currently stored events.
		Set<EventI> extracted = new HashSet<EventI>();
		for (EventI e : this.currentStoredEvents) {
			if (e instanceof ES_EventI) {
				assert	e.getTimeOfOccurrence().
											equals(this.currentStateTime);
				// Inserting events in the event list allow to sort them
				// according to their priority.
				this.scheduleEvent((ES_EventI) e);
				extracted.add(e);
			}
		}
		this.currentStoredEvents.removeAll(extracted);

		// Execute the non ES events and possibly ES events if the model
		// wishes to do so manually.
//		if (this.currentStoredEvents.size() > 1) {
//			TO DO
//			this.confluentTransition(elapsedTime);
//		} else {
			this.userDefinedExternalTransition(elapsedTime);
//		}
		// all of them must have been processed.
		this.currentStoredEvents.clear();

		this.nextTimeAdvance = this.timeAdvance();
		this.timeOfNextEvent =
						this.currentStateTime.add(this.nextTimeAdvance);

		// Postconditions
		if (!this.getTimeOfNextEvent().equals(Time.INFINITY)) {
			assert	this.getTimeOfNextEvent().subtract(
												this.getCurrentStateTime()).
									equals(this.getNextTimeAdvance()) :
					new AssertionError("Postcondition violation: "
									+ "getTimeOfNextEvent().subtract("
									+ "getCurrentStateTime())."
									+ "equals(this.getNextTimeAdvance())");
		}
	}

	/**
	 * verify that all events remaining in the currently stored events are
	 * not ES events; hence the user can find in the current stored events
	 * non ES imported events and in the event list the ES imported ones.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code assertOnCurrentStoredEvents(e -> !(e instanceof ES_EventI))}
	 * post	{@code true}	// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#userDefinedExternalTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			userDefinedExternalTransition(Duration elapsedTime)
	{
		super.userDefinedExternalTransition(elapsedTime);

		assert	assertOnCurrentStoredEvents(e -> !(e instanceof ES_EventI)) :
				new AssertionError("Precondition violation: "
										+ "assertOnCurrentStoredEvents("
										+ "e -> !(e instanceof ES_EventI))");
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#confluentTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			confluentTransition(Duration elapsedTime)
	{
		throw new RuntimeException("AtomicES_Model#confluentTransition not"
												+ " implemented yet!");
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#userDefinedConfluentTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			userDefinedConfluentTransition(Duration elapsedTime)
	{
		throw new RuntimeException(
					"AtomicES_Model#userDefinedConfluentTransition not"
												+ " implemented yet!");
	}

	/**
	 * return true if {@code event} appears in the scheduled internal events.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code event != null}
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param event	event to be tested.
	 * @return		true if {@code event} appears in the scheduled internal events.
	 */
	public boolean		isScheduled(ES_EventI event)
	{
		assert	event != null :
				new AssertionError("Precondition violation: event != null");

		return !((ES_Event)event).isCancelled() &&
											this.eventList.contains(event);
	}

	/**
	 * return true if all objects in {@code events} are currently scheduled
	 * internal events.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code events != null}
	 * pre	{@code events.stream().allMatch(e -> e != null)}
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param events	set of events to be tested.
	 * @return			true if all objects in {@code events} are currently scheduled internal events.
	 */
	public boolean		areScheduled(Set<ES_EventI> events)
	{
		assert	events != null :
				new AssertionError("Precondition violation: events != null");
		assert	events.stream().allMatch(e -> e != null) :
				new AssertionError("Precondition violation: "
								+ "events.stream().allMatch(e -> e != null)");

		return events.size() > 0 &&
						events.stream().allMatch(
								e -> !((ES_Event)e).isCancelled()) &&
											this.eventList.containsAll(events);
	}

	/**
	 * schedule a new internal event.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code event != null && !isScheduled(event)}
	 * post	{@code isScheduled(event)}
	 * post	{@code getNumberOfScheduledEvents() == getNumberOfScheduledEvents()at_pre + 1}
	 * </pre>
	 *
	 * @param event		event to be scheduled.
	 */
	protected void		scheduleEvent(ES_EventI event)
	{
		assert	event != null && !isScheduled(event) :
				new AssertionError("Precondition violation: "
									+ "event != null && !isScheduled(event)");

		this.eventList.add(event);
	}

	/**
	 * schedule a set of new internal events.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code events != null}
	 * pre	{@code events.stream().allMatch(e -> e != null)}
	 * pre	{@code !areScheduled(events)}
	 * post	{@code areScheduled(events)}
	 * </pre>
	 *
	 * @param events	set of events to be scheduled.
	 */
	protected void		scheduleEvents(Set<ES_EventI> events)
	{
		assert	events != null  :
				new AssertionError("Precondition violation: events != null");
		assert	events.stream().allMatch(e -> e != null) :
				new AssertionError("Precondition violation: "
								+ "events.stream().allMatch(e -> e != null)");
		assert	!areScheduled(events) :
				new AssertionError("Precondition violation: "
								+ "!areScheduled(events)");

		this.eventList.addAll(events);
	}

	/**
	 * cancel a previously scheduled internal event.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code event != null && isScheduled(event)}
	 * post	{@code !isScheduled(event)}
	 * </pre>
	 *
	 * @param event		event to be scheduled.
	 */
	protected void		cancelEvent(ES_EventI event)
	{
		assert	event != null && isScheduled(event) :
				new AssertionError("Precondition violation: "
								+ "event != null && isScheduled(event)");

		((ES_Event)event).cancel();
	}

	/**
	 * cancel the events resulting from the execution of a previous
	 * event that generated them.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code events != null && }
	 * pre	{@code events.size() > 0 && areScheduled(events)}
	 * post	{@code !areScheduled(events)}
	 * </pre>
	 *
	 * @param events	set of events to be scheduled.
	 */
	protected void		cancelEvents(Set<ES_EventI> events)
	{
		assert	events != null && events.stream().allMatch(e -> e != null) :
				new AssertionError("Precondition violation: "
								+ "events != null && events.stream()."
								+ "allMatch(e -> e != null)");
		assert	events.size() > 0 && areScheduled(events) :
				new AssertionError("Precondition violation: "
								+ "events.size() > 0 && areScheduled(events)");

		for (ES_EventI e : this.eventList) {
			((ES_Event)e).cancel();
		}
	}

	// -------------------------------------------------------------------------
	// Debugging behaviour
	// -------------------------------------------------------------------------

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#showCurrentStateContent(java.lang.String, fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			showCurrentStateContent(
		String indent,
		Duration elapsedTime
		)
	{
		super.showCurrentStateContent(indent, elapsedTime);
		StringBuffer sb = new StringBuffer(indent);
		sb.append("event list = ");
		this.eventListAsString(sb);
		System.out.println(sb.toString());
	}

	/**
	 * produce a string representation of the event list of this model in
	 * the given string buffer.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code sb != null}
	 * post	{@code true}	// no postcondition.
	 * </pre>
	 *
	 * @param sb	string buffer to which the representation is appended.
	 */
	protected void		eventListAsString(StringBuffer sb)
	{
		assert	sb != null;

		sb.append("EventList{");
		ArrayList<ES_EventI> temp = new ArrayList<>();
		while (this.eventList.size() > 0) {
			ES_EventI e = this.eventList.remove();
			temp.add(e);
			sb.append(e.eventAsString());
			if (this.eventList.size() > 0) {
				sb.append(", ");
			}
		}
		sb.append('}');
		this.eventList.addAll(temp);
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#modelContentAsString(java.lang.String, java.lang.StringBuffer)
	 */
	@Override
	protected void		modelContentAsString(String indent, StringBuffer sb)
	{
		super.modelContentAsString(indent, sb);
		sb.append(indent);
		sb.append("event list = ");
		this.eventListAsString(sb);
		sb.append('\n');
	}
}
// -----------------------------------------------------------------------------
